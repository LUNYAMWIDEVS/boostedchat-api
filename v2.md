# V2

## Multichannel and Sandbox Implemantation

<details>
  <summary><b>Channels</b></summary>
  <p>
  The social media platforms/communication channels to use for outreach. Each channels has a microservice which is running which needs to have both the external base url as well as the internal (docker network) url supplied here.
  </p>

  <h3> Features:</h3></br>

  - Channels have registered activities which can be performed in them.

<h3>Actions</h3></br>

- [X] registration of channels
- [X] registration of channel activities

<h3> Channel Activities</h3>

- Message
- Like
- Comment
- broadcast
- ...

<details>
  <summary>Models</summary>
  <strong>Channels</strong>
  <pre>
    <code class="python">
class Channel(models.Model):
    name = models.CharField(max_length=100, unique=True, ) # case insensitive
    docker_url = models.CharField(max_length=255, blank=False)
    external_url = models.CharField(max_length=255, blank=False)
    description = models.TextField(blank=True, null=True)
    </code>
  </pre>
</details>
</details>

<details>
  <summary><b>Sales Reps</b></summary>
  <p>
  Sales representatives.</br>
  </br>
  <p>
  A sales_rep is a registered user. <i>It will be required that they be able to only access their own activities in the frontend</i></p>
  <h3> Features:</h3></br>

  - Sales representatives can communicate through various channels to the leads.
  - The sales_rep is assumed to be a real person so that country and city are globally set for all channels
  - <b>Profiles:</b> Sales rep profiles
  - <b>Availability:</b> The sales_rep can also be globally marked as available/not available. Availability can also be marked per channel. The global setting will override the channel specific setting if marked as false.
  - <b>Sandbox:</b> A sales_rep channel can be set as sandbox for the purpose of testing the internal orking of the code for the particular channel without sending communication to the social media platform
  - Each sales_rep has a maximum daily capacity for each activity in each channel to avoid robot detection
  - Sales reps work in daily shifts (start and stop time specified per activity). The shift starts at 0000 hrs for the specified timezone
  - <b>Activities:</b> Each activity has working hours set. If working hours are not set, the global working hours for the channel will be used.
  </p>


 <h3> Actions:</h3></br>

- [X] Registration of Users
- [X] Registration of Sales_reps
- [X] Creation of sales_rep channels
- [X] Activity settings for sales_reps in different channels
- [X] Creating of working shifts ***Has an issue***

 <h3> Issues:</h3></br>

- [ ] Shift number should be unique. (unique_together seems to be having an issue)

<details>
  <summary>Models</summary>
  <strong>Channels</strong>
  <pre>
    <code class="python">
class SalesRep(BaseModel):
    autoLoad = True
    permissionClasses = []
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True, blank=True, unique=True)
    phone_number = models.CharField(max_length=20, blank=True, null=True)
    full_name = models.CharField(max_length=255)
    ig_username = models.CharField(max_length=255, null=True, blank=True) # backward compartibility
    ig_password = models.CharField(max_length=255, null=True, blank=True) # backward compartibility
    instagram = models.ManyToManyField(Account, blank=True) # backward compartibility
    available = models.BooleanField(default=True) # backward compartibility
    country = models.TextField(default="US")
    city = models.TextField(default="Pasadena")

    def __str__(self) -> str:
        return self.user.email
    
# All Channels Registered to sales_rep, with their credentials where applicable
class SalesRepChannel(models.Model):
    autoLoad = True
    permissionClasses = []
    sales_rep = models.ForeignKey(SalesRep, on_delete=models.CASCADE)
    channel = models.ForeignKey(Channel, on_delete=models.CASCADE)
    username = models.CharField(max_length=255, null=True, blank=True)  
    password = models.CharField(max_length=255, null=True, blank=True)
    available = models.BooleanField(default=True) 
    start_time = models.TimeField()
    end_time = models.TimeField()
    max_capacity = models.IntegerField(default=0)
    timezone = models.CharField(max_length=255)

    class Meta:
        unique_together = ('sales_rep', 'channel')

    def __str__(self):
        return f"{self.sales_rep}({self.sales_rep.full_name}) on {self.channel}"

## this is required so that we can be able to define the working hours per activity
class SalesRepChannelActivities(models.Model): # all the activities which a sales_rep can do
    autoLoad = True
    permissionClasses = []
    sales_rep_channel = models.ForeignKey(SalesRepChannel, on_delete=models.CASCADE)
    activity = models.ForeignKey(ChannelActivities, on_delete=models.CASCADE)
    start_time = models.TimeField(null=True, blank=True) # if this is not defined, we will use for SalesRepChannel
    end_time = models.TimeField(null=True, blank=True) # if this is not defined, we will use for SalesRepChannel
    max_capacity = models.IntegerField(null=True, blank=True) # if this is not defined, we will use for SalesRepChannel
    # timezone = models.CharField(max_length=255) # we will use for SalesRepChannel
    class Meta:
        unique_together = ('sales_rep_channel', 'activity')

    def __str__(self):
        return f"{self.sales_rep} on {self.channel}"

# Records each shift
class SalesRepsChannelWorkingShifts(models.Model):
    autoLoad = True
    permissionClasses = []
    sales_rep = models.ForeignKey(SalesRep, on_delete=models.CASCADE)
    shift_number = models.IntegerField()
    shift_date = models.DateField()

    unique_together = ('sales_rep', 'shift_number', 'shift_date')

    def __str__(self):
        return f"{self.sales_rep} on {self.channel}" # chatGPT modify what to return here
    
# Records the activity done in each shift
class SalesRepChannelWorkingShiftActivities(models.Model):
    autoLoad = True
    permissionClasses = []
    sales_rep_channel_shift = models.ForeignKey(SalesRepsChannelWorkingShifts, on_delete=models.CASCADE)
    activity = models.ForeignKey(SalesRepChannelActivities, on_delete=models.CASCADE)

    def __str__(self):
        return f"{self.sales_rep} on {self.channel}" # chatGPT modify what to return here

## Running averages are per activity
##
class SalesRepChannelRunningAverages(models.Model): 
    autoLoad = True
    permissionClasses = []
    sales_rep_channel = models.ForeignKey(SalesRepChannel, on_delete=models.CASCADE)
    date = models.DateField()
    average = models.IntegerField() # should increase daily but not be more than max_capacity

## WorkingShiftErrors: record errors encountered for each activity during a shift
class SalesRepChannelWorkingShiftErrors(models.Model):
    autoLoad = True
    permissionClasses = []
    sales_rep_channel_shift = models.ForeignKey(SalesRepsChannelWorkingShifts, on_delete=models.CASCADE)
    message = models.TextField()
    code = models.IntegerField()
    level = models.IntegerField(default=0) # 0: info, 0: warning, 1: error

    </code>
  </pre>
</details>
</details>